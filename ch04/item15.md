---
theme: gaia
_class: lead
paginate: true
backgroundColor: #fff
backgroundImage: url('https://marp.app/assets/hero-background.jpg')
marp: true
---


## **아이템 15. 클래스와 멤버의 접근 권한을 최소화하라**
---

## **잘 설계된 컴포넌트**

- 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨겨 구현
- 오직 API를 통해 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 관여하지 않는다.

→ 정보은닉, 혹은 캡슐화라고 함 

---

### 정보은닉 장점

- 시스템 개발 속도를 높인다.
- 시스템 관리 비용을 낮춘다.
- 성능 최적화에 도움을 준다.
- 소프트웨어 재사용성을 높인다.
- 큰 시스템 제작 난이도를 낮춰준다.

---


### 접근 제어 매커니즘

> 접근제어 매커니즘은 클래스, 인터페이스, 멤버의 접근 허용 범위를 명시한다.
> 
- 클래스, 인터페이스 등 각 요소의 접근성은 그 요소가 **선언된 위치와 접근 제한자**로 정해진다. 이 접근제한자를 제대로 활용하는것이 정보 은닉의 핵심이다.


---


### 접근 제어 매커니즘의 기본 원칙과 컴포넌트 설계



<br>

접근제어 매커니즘의 기본원칙은 간단하다. **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.** 

모든 클래스와 멤버의 접근성을 최대한 줄여야하기 때문에 **항상 제일 낮은 접근 수준을 부여**해야 한다.



---


### 1. Top Level 클래스, 인터페이스 접근제한자
톱레벨 클래스나 인터페이스에 부여할 수 있는 접근 수준은 package-private 그리고 public 두가지다.

- `public`으로 선언시 공개 API가 되며, 하위호완을 위해 계속해서 관리해줘야 한다. 만약, `public`일 필요가 없는 클래스가 있다면 클래스의 접근 수준을 `package-private`톱레벨 클래스로 좁히는 일이 필요하다.
- `package-private`으로 선언하면 해당 패키지 안에서만 이용할 수 있다. 패키지 외부에서 사용할 이유가 없다면 `package-private`으로 선언하자. `package-private`은 내부구현이 되어 언제든 수정이 가능하고 클라이언트에 피해없이 수정, 교체, 제거가 가능하다.


---

- 한 클래스에서만 사용하는 `package-private` 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 `private static`으로 중첩시키자.

- 톱레벨로 두면 같은 패키지의 모든 클래스가 접근할 수 있지만, `private static`으로 중첩시키면 바깥 클래스 하나에서만 접근할 수 있다.


---

### 2.  멤버(필드, 메서드, 중첩클래스, 중첩 인터페이스)와 접근 제한자



- public, protected, package-private, private 모두 부여할 수 있다

|                 | 해당 클래스 | 같은 패키지 | 상속받은 클래스 | 외부 |
| --------------- | ----------- | ----------- | --------------- | ---- |
| public          | O           | O           | O               | O    |
| protected       | O           | O           | O               | X    |
| package-private | O           | O           | X               | X    |
| private         | O           | X           | X               | X    |

---


### 3.  공개 API 설계 후 모든 멤버는 private으로 만들자.

- 같은 패키지의 다른 클래스 접근이 필요할 때만 `package-private`으로 변경하자.
- 변경이 잦다면 컴포넌트를 더 분해해야 하는것이 아닌지 고민해봐야 한다.


---


- 단, Serializable을 구현한 클래스에서는 `private`과 `package-private` 멤버 필드들이 의도치 않게 공개 API가 될 수 있음에 주의하자.

- public 클래스에서는 멤버의 접근 수준을 `package-private`에서 `protected`로 바꾸는 순간 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어진다. public 클래스의 `protected` 멤버는 공개 API이므로 영원히 지원돼야 한다.

-  따라서 `protected` 멤버의 수는 적을수록 좋다.

---




### 4. 접근 제한을 방해하는 제약 : 리스코프 치환원칙

> 상위 클래스의 메서드를 재정의할 때는 그 접근수준을 상위 클래스보다 좁게 설정할 수 없다.
> 
- 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(리스코프의 치환원칙)을 지키기 위해 필요하다.
- 이 제약을 어길 경우 하위 클래스를 컴파일 할 때 컴파일 에러가 발생한다.
- 단, 클래스가 인터페이스를 구현할 경우 모든 메서드를 `public`으로 선언해야 한다.


---



### 5. 코드를 테스트하려는 목적으로 접근제한을 풀어주면 안된다.

- 코드를 테스트하려는 목적으로 클래스, 인터페이스, 멤버의 접근범위를 `package-private` 이상으로 사용하는것은 지양해야 한다. 테스트만을 위해 클래스, 인터페이스 멤버를 공개 API로 만들어서는 안된다.
- 테스트 코드를 테스트 대상과 같은 패키지에 두면 `package-private` 요소까지 접근할 수 있게된다.


---


### 6. public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.

- 필드와 관련된 모든것에 불변을 보장하기 힘들어지며, `public` 가변필드를 갖는 클래스는 일반적으로 스레드 안정성이 없다.

---



### 7. 상수인 public static final 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다.

- 만약, 기본타입이나 불변 객체를 참조하지 않는다면 필드와 관련된 모든것에 불변을 보장하기 힘들어지며, `public` 가변필드를 갖는 클래스는 일반적으로 스레드 안정하지 않기 때문이다.
- 가변 객체를 참조한다면 `final`이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다. (참조된 객체가 수정될 수 있기 때문이다.)


---

### 8. 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

- 이런 필드나 접근자를 제공한다면 클라이언트에서 배열 내용을 수정할 수 있게 된다.
- 길이가 `0`이 아닌 배열은 모두 변경가능하니 주의해야 한다.


```java
    public static final Integer[] VALUES = new Integer[10]
```


---

```java
class Example {
    public static final Integer[] VALUES = {1, 2, 3};
}

class ExampleMain {
    public static void main(String[] args) {
        System.out.println(Example.VALUES[0]);
        Example.VALUES[0] = 10;
        System.out.println(Example.VALUES[0]);
    }
}
// 실행결과
1
10
```


---


위 코드는 클라이언트에서 배열 내용을 수정이 가능하다. 이런 상황을 방지하기 위한 방법에는 2가지가 있다.

**[첫 번째 해결방법: private 배열과 public 불변리스트 추가]**

```java
private static final Integer[] VALUES = {1, 2, 3};
public static final List<Integer> VALUES_LIST = Collections.unmodifiableList(Arrays.asList(VALUES));
```

첫 번째 해결방법은 기존의 `public` 배열을 `private` 배열로 만들고 `public` 불변 리스트를 추가하는 것이다.

---

**[두 번째 해결방법: private 배열과 복사본을 반환하는 public 메서드 추가]**

```java
private static final Integer[] VALUES = {1, 2, 3};

public static final Integer[] values(){
	    return VALUES.clone();
}
```


두 번째 해결방법은 기존의 `public` 배열을 `private` 배열로 만들고 그 복사본을 반환하는 `public` 메서드를 추가하는 방법이다. (방어적 복사)

---


### 자바 9에서 추가된 두가지 암묵적 접근 수준


> 모듈 시스템을 사용해서 외부에서의 접근을 제어할 수 있다.
> 
- 클래스가 패키지의 묶음이듯 모듈은 패키지의 묶음이다. 모듈은 속하는 패키지중 공개할 것들을 선언(`module-info.java` 파일에)한다.
- `protected` 혹은 `public` 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서 접근이 불가능하다. 물론 모듈 안에서 공개(`exports`)로 선언했는지에 영향을 받지 않는다.
- 모듈 시스템을 사용하면 클래스를 외부에 공개하지 않고 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다.
- 앞서 다룬 4개의 기존 접근수준과 달리 모듈에 적용되는 새로운 두 접근 수준은 상당히 주의해서 사용해야 한다.

---


- 모듈의 `jar`파일을 애플리케이션의 클래스패스(`classpath`)에 두면 그 모듈안의 모든 패키지는 마치 모듈이 없는 것처럼 행동한다. 즉, 모듈이 공개됐는지 여부와 관계없이 `public` 클래스가 선언한 모든 `public` 혹은 `protected` 멤버를 모듈 밖에서도 접근할 수 있게 된다.
- 이 접근수준을 적극적으로 활용한 대표적인 예시로 `JDK`가 있다. 자바 라이브러리에서 공개하지 않은 패키지들은 해당 모듈 밖에서는 절대로 접근이 불가능하다.

**단, 아직은 모듈 개념이 널리 사용되지 않고 있으니 알아만 두고 사용하지 않는것이 좋다.**

---


### 정리

프로그램 요소의 접근성은 가능한 최소한으로 하자. 꼭 필요한 것만 골라서 최소한의 `public` API를 설계해야 한다. 

그 외의 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다.


 `public` 클래스는 상수용 `public static final` 필드 외에는 어떠한 `public` 필드도 가져서는 안된다. 

`public static final` 필드가 참조하는 객체가 불변인지 확인하라.
